### vim:syntax=js
###
### PREP SOURCE.. not in the mood for jaggler.. maybe i'll have to port later
### The following warning isn't for you if you can read this.
#// This file has been generated using prep.   http://perl.pages.de
###
### Currently no ifdefs in here.
##
## TODO: GeKo sagt: I mean you are not saving a cert but saying so at the moment...

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * ''Certificate Patrol'' was conceived by Carlo v. Loesch and
 * implemented by Aiko Barz, Mukunda Modell and Carlo v. Loesch.
 *
 * http://patrol.psyced.org
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *  
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete 
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *                              
 * ***** END LICENSE BLOCK ***** */
##
## The original Certificate Patrol code was slightly adapted by Georg Koppen, 
## JonDos GmbH 2010. The wildcard certificate functionality was developed by 
## Georg Koppen, JonDos GmbH 2010.

// This source code is formatted according to half-indented KNF.
var CertPatrol = {
    // Main
    onLoad: function() {
	this.initialized = true;
	this.strings = document.getElementById("CertPatrol-strings");
	this.dbinit();
	this.init();
    },

    // DB init
    dbinit: function() {
	this.dbh = null;
	this.dbselect = null;
	this.dbinsert = null;
	this.dbupdate = null;

	try {
	    var file = Components.classes["@mozilla.org/file/directory_service;1"]
	      .getService(Components.interfaces.nsIProperties)
	      .get("ProfD", Components.interfaces.nsIFile);
	    var storage = Components.classes["@mozilla.org/storage/service;1"]
	      .getService(Components.interfaces.mozIStorageService);
	    file.append("CertPatrol.sqlite");

	    // Must be checked before openDatabase()
	    var exists = file.exists();

	    // Now, CertPatrol.sqlite exists
	    this.dbh = storage.openDatabase(file);

	    // CertPatrol.sqlite initialization
##	    // "GMT" is a historic lie here.. before version 1.3 we used to work
##	    // with notAfterGMT etc and try to parse the various renderings of it.
##	    // now it is too late and pointless to change the name in the sqlite
##	    // field. how i love SQL for its terrific flexibility...  ;)
##	    // why do most web apps still use this 1970s legacy interface?
	    if (!exists) {
		this.dbh.executeSimpleSQL(
		  "CREATE TABLE version (version INT)");
		this.dbh.executeSimpleSQL(
		  "INSERT INTO version (version) VALUES (1)");
		this.dbh.executeSimpleSQL(
		  "CREATE TABLE certificates ("+
		    "host VARCHAR, commonName VARCHAR, organization VARCHAR, organizationalUnit VARCHAR, "+
		    "serialNumber VARCHAR, emailAddress VARCHAR, notBeforeGMT VARCHAR, notAfterGMT VARCHAR, "+
		    "issuerCommonName VARCHAR, issuerOrganization VARCHAR, issuerOrganizationUnit VARCHAR, "+
		    "md5Fingerprint VARCHAR, sha1Fingerprint VARCHAR, "+
		    "issuerMd5Fingerprint VARCHAR, issuerSha1Fingerprint VARCHAR, cert BLOB)");
	    } else {
		var stmt = this.dbh.createStatement("SELECT version FROM version WHERE version < 2");
		try {
		    var old = stmt.executeStep();
		} catch (err) {
		    this.warn("Error trying to check SQL schema version: "+ err);
		} finally {
		    stmt.reset();
		}
		if (old) {
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN issuerMd5Fingerprint VARCHAR");
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN issuerSha1Fingerprint VARCHAR");
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN cert BLOB");
		    this.dbh.executeSimpleSQL("UPDATE version SET version = 2");
		}
	    }

	    // Prepared statements
	    this.dbselect = this.dbh.createStatement(
	      "SELECT * FROM certificates WHERE host=?1");
	    this.dbselectWild = this.dbh.createStatement(
	      "SELECT * FROM certificates WHERE sha1Fingerprint=?13");
	    this.dbinsert = this.dbh.createStatement(
	      "INSERT INTO certificates ("+
		"host, commonName, organization, organizationalUnit, serialNumber, emailAddress, "+
		"notBeforeGMT, notAfterGMT, issuerCommonName, issuerOrganization, issuerOrganizationUnit, "+
		"md5Fingerprint, sha1Fingerprint, issuerMd5Fingerprint, issuerSha1Fingerprint, cert) "+
	      "VALUES (?1,?2,?3,?4,?5,?6,?7,?8,?9,?10,?11,?12,?13,?14,?15,?16)");
	    this.dbupdate = this.dbh.createStatement(
	      "UPDATE certificates SET "+
		"commonName=?2, organization=?3, organizationalUnit=?4, serialNumber=?5, emailAddress=?6, "+
		"notBeforeGMT=?7, notAfterGMT=?8, issuerCommonName=?9, issuerOrganization=?10, issuerOrganizationUnit=?11, "+
		"md5Fingerprint=?12, sha1Fingerprint=?13, issuerMd5Fingerprint=?14, issuerSha1Fingerprint=?15, cert=?16 "+
	      "WHERE host=?1");
	}
	catch(err) {
	    this.warn("Error initializing SQLite operations: "+ err);
	}
    },

    // Application trigger
    init: function() {
	this.prefs = Cc["@mozilla.org/preferences-service;1"]
	  .getService(Ci.nsIPrefService)
	  .getBranch("certpatrol.")
	  .QueryInterface(Ci.nsIPrefBranch2);

	this.registerObserver('http-on-examine-response');
    },

    // helper functions for advanced patrol
    isodate: function(tim) {
	if (isNaN(tim)) {
##	    // this part of code can go when there are no more pre version 1.3
##	    // Certpatrol.sqlite instances around..
##	    //
##	    // i think i saw some cert dates without time info appended..
	    var iso = tim.replace(/^(\d\d)\/(\d\d)\/(\d+)/, "$3-$1-$2");
	    // upcoming Y3K bug, but you must delete this line before 2020
	    if (iso != tim) {
		if (iso[0] != '2') iso = "20"+ iso;
		return iso;
	    }
	}
	var d = new Date(tim / 1000);
##  // locale string is too verbose. we don't need weekdays and time zones here
##  // i was really afraid of having to do this. i love bad apis like Date().
##  return d.getFullYear() +"-"+
##	  (d.getMonth() < 10 ? "0"+ d.getMonth() : d.getMonth()) +"-"+
##	  (d.getDay() < 10 ? "0"+ d.getDay() : d.getDay()) +" "+
##	  (d.getHours() < 10 ? "0"+ d.getHours() : d.getHours()) +":"+
##	  (d.getMinutes() < 10 ? "0"+ d.getMinutes() : d.getMinutes());
##      // mozilla has this nice strftime extension to Date called toLocaleFormat()
	return d.toLocaleFormat("%Y-%m-%d %H:%M:%S");
##	// btw, this is not exactly ISO 8601 conformant but rather
##	// preserves its original intent.. universal readability (thus no 'T')
    },
    timedelta: function(tim) {
	if (!isNaN(tim)) tim /= 1000;
	var d = new Date(tim);
	// Y2K bug in Javascript...  :)
	if (d.getFullYear() < 2000) d.setFullYear(100 + d.getFullYear());
	var now = new Date();
	//alert("Now is "+ now.getTime() +" and cert is "+ d.getTime());
	return d.getTime() - now.getTime();
    },
    daysdelta: function(td) {
	td = Math.round(td / 86400000);	// milliseconds per day
	return " ("+ this.strings.getFormattedString(td < 0 ?
	  "daysPast" : "daysFuture", [td < 0 ? -td : td]) +")";
    },

    byteArrayToString: function(ba) {
	var s = '';
	for (var i = 0; i < ba.length; i++)
            s += String.fromCharCode(ba[i]);
	return s;
    },

    newCertObj: function() {
	return {
	    threat:0,
	    info:"",
	    host:"",
	    moz:{
		  commonName:"",
		  organization:"",
		  organizationalUnit:"",
		  serialNumber:"",
		  emailAddress:"",
		  notBefore:"",
		  notAfter:"",
		  issuerCommonName:"",
		  issuerOrganization:"",
		  issuerOrganizationUnit:"",
		  md5Fingerprint:"",
		  sha1Fingerprint:"",
		  issuerMd5Fingerprint:"",
		  issuerSha1Fingerprint:"",
		  cert:null,
	    },
	    sql:{
		  commonName:"",
		  organization:"",
		  organizationalUnit:"",
		  serialNumber:"",
		  emailAddress:"",
		  notBefore:"",
		  notAfter:"",
		  issuerCommonName:"",
		  issuerOrganization:"",
		  issuerOrganizationUnit:"",
		  md5Fingerprint:"",
		  sha1Fingerprint:"",
		  issuerMd5Fingerprint:"",
		  issuerSha1Fingerprint:"",
		  cert:null,
	    },
	    lang:{
		  newEvent:this.strings.getString("newEvent"),
		  wildEvent:this.strings.getString("newEvent"),
		  changeEvent:this.strings.getString("changeEvent"),
		  newCert:this.strings.getString("newCert"),
		  oldCert:this.strings.getString("oldCert"),
		  issuedTo:this.strings.getString("issuedTo"),
		  issuedBy:this.strings.getString("issuedBy"),
		  validity:this.strings.getString("validity"),
		  fingerprints:this.strings.getString("fingerprints"),
		  commonName:this.strings.getString("commonName"),
		  organization:this.strings.getString("organization"),
		  organizationalUnit:this.strings.getString("organizationalUnit"),
		  serialNumber:this.strings.getString("serialNumber"),
		  emailAddress:this.strings.getString("emailAddress"),
		  notBefore:this.strings.getString("notBefore"),
		  notAfter:this.strings.getString("notAfter"),
		  md5Fingerprint:this.strings.getString("md5Fingerprint"),
		  sha1Fingerprint:this.strings.getString("sha1Fingerprint"),
		  viewDetails:this.strings.getString("viewDetails"),
		  hierarchy:this.strings.getString("hierarchy"),
	    },
	};
    },

    fillCertObj: function(obj, cert) {
	obj.cert = cert;
	obj.notBefore = cert.validity.notBefore;
	obj.notAfter = cert.validity.notAfter;
	obj.issuerMd5Fingerprint = cert.issuer.md5Fingerprint;
	obj.issuerSha1Fingerprint = cert.issuer.sha1Fingerprint;

	var keys = ['commonName', 'organization', 'organizationalUnit', 'serialNumber', 'emailAddress',
		    'issuerCommonName', 'issuerOrganization', 'issuerOrganizationUnit',
		    'md5Fingerprint', 'sha1Fingerprint'];
	for (var i in keys)
	    obj[keys[i]] = cert[keys[i]];
    },


    registerObserver: function(topic) {
	var observerService = Components.classes["@mozilla.org/observer-service;1"]
            .getService(Components.interfaces.nsIObserverService);
	observerService.addObserver(this, topic, false);
    },

    unregisterObserver: function(topic) {
	var observerService = Components.classes["@mozilla.org/observer-service;1"]
            .getService(Components.interfaces.nsIObserverService);
	observerService.removeObserver(this, topic);
    },

    observe: function(channel, topic, data) {
##	this.log('>> observe:', [channel, topic, data]);
	const Ci = Components.interfaces;

	channel.QueryInterface(Ci.nsIHttpChannel);
	var host = channel.URI.hostPort;
##	this.log('URI: '+ channel.URI.spec);

	var si = channel.securityInfo;
	if (!si)
	    return;

	var nc = channel.notificationCallbacks || channel.loadGroup.notificationCallbacks;
	if (!nc)
	    return;

	try {
	    var win = nc.getInterface(Ci.nsIDOMWindow);
	} catch (e) {
	    return; // no window for e.g. favicons
	}

	if (!win.document)
	    return;

	var browser = gBrowser.getBrowserForDocument(win.top.document);
	if (!browser)
	    return; // no browser for e.g. favicons

	var wpl = Ci.nsIWebProgressListener;
	// proceed only if the page is considered secure,
	if (!(browser.securityUI.state & wpl.STATE_IS_SECURE))
	    return;
	var sp = si.QueryInterface(Ci.nsISSLStatusProvider);
	if (!sp) return;

	var stats = sp.SSLStatus;
	if (!stats) return;

	var stati = stats.QueryInterface(Ci.nsISSLStatus);
	if (!stati) return;

	var cert = stati.serverCert;
	if (!cert) return;

	// store certs in the browser object so we can
	// show only one notification per host for a browser tab
	if (browser.__certs && browser.__certs[host] && cert.equals(browser.__certs[host]))
	    return;
	browser.__certs = browser.__certs || {};
	browser.__certs[host] = cert;

	// The interesting part
	var certobj = this.newCertObj();
	certobj.host = host;
	this.fillCertObj(certobj.moz, cert);
	this.certCheck(browser, certobj);
    },

    // Certificate check
    certCheck: function(browser, certobj) {
	this.log('>> certCheck: '+ certobj.host);
	var found = false;

	if (this.last_sha1Fingerprint && this.last_sha1Fingerprint == certobj.moz.sha1Fingerprint) return;
	else this.last_sha1Fingerprint = certobj.moz.sha1Fingerprint;

	var pbm = false;
	var pbs = Components.classes["@mozilla.org/privatebrowsing;1"];
	if (pbs) {
	    pbs = Components.classes["@mozilla.org/privatebrowsing;1"].getService(Components.interfaces.nsIPrivateBrowsingService);
	    pbm = pbs.privateBrowsingEnabled;
	}
	var certdb = Components.classes["@mozilla.org/security/x509certdb;1"].getService(Components.interfaces.nsIX509CertDB);
	// Get certificate
	var stmt = this.dbselect;
	try {
	    stmt.bindUTF8StringParameter(0, certobj.host);
	    if (stmt.executeStep()) {
		found = true;

		certobj.sql.commonName = stmt.getUTF8String(1);
		certobj.sql.organization = stmt.getUTF8String(2);
		certobj.sql.organizationalUnit = stmt.getUTF8String(3);
		certobj.sql.serialNumber = stmt.getUTF8String(4);
		certobj.sql.emailAddress = stmt.getUTF8String(5);
		certobj.sql.notBefore = stmt.getUTF8String(6);
		certobj.sql.notAfter = stmt.getUTF8String(7);
		certobj.sql.issuerCommonName = stmt.getUTF8String(8);
		certobj.sql.issuerOrganization = stmt.getUTF8String(9);
		certobj.sql.issuerOrganizationUnit = stmt.getUTF8String(10);
		certobj.sql.md5Fingerprint = stmt.getUTF8String(11);
		certobj.sql.sha1Fingerprint = stmt.getUTF8String(12);
		certobj.sql.issuerMd5Fingerprint = stmt.getUTF8String(13);
		certobj.sql.issuerSha1Fingerprint = stmt.getUTF8String(14);
		var blob = {};
		stmt.getBlob(15, {}, blob);
		if (blob.value.length)
		    certobj.sql.cert = certdb.constructX509FromBase64(window.btoa(this.byteArrayToString(blob.value)));
	    }
	} catch(err) {
	    this.warn("Error trying to check certificate: "+ err);
	} finally {
	    stmt.reset();
	}

	// The certificate changed 
	if (found && (!certobj.sql.cert || !certobj.moz.cert.equals(certobj.sql.cert))) {
	    var wild = this.wildcardCertCheck(certobj.moz.commonName,
	      certobj.moz.sha1Fingerprint);

	    if (!pbm) {
		// DB update
		stmt = this.dbupdate;
		try {
		    stmt.bindUTF8StringParameter( 0, certobj.host);
		    stmt.bindUTF8StringParameter( 1, certobj.moz.commonName);
		    stmt.bindUTF8StringParameter( 2, certobj.moz.organization);
		    stmt.bindUTF8StringParameter( 3, certobj.moz.organizationalUnit);
		    stmt.bindUTF8StringParameter( 4, certobj.moz.serialNumber);
		    stmt.bindUTF8StringParameter( 5, certobj.moz.emailAddress);
		    stmt.bindUTF8StringParameter( 6, certobj.moz.notBefore);
		    stmt.bindUTF8StringParameter( 7, certobj.moz.notAfter);
		    stmt.bindUTF8StringParameter( 8, certobj.moz.issuerCommonName);
		    stmt.bindUTF8StringParameter( 9, certobj.moz.issuerOrganization);
		    stmt.bindUTF8StringParameter(10, certobj.moz.issuerOrganizationUnit);
		    stmt.bindUTF8StringParameter(11, certobj.moz.md5Fingerprint);
		    stmt.bindUTF8StringParameter(12, certobj.moz.sha1Fingerprint);
		    stmt.bindUTF8StringParameter(13, certobj.moz.issuerMd5Fingerprint);
		    stmt.bindUTF8StringParameter(14, certobj.moz.issuerSha1Fingerprint);
		    var der = certobj.moz.cert.getRawDER({});
		    stmt.bindBlobParameter(15, der, der.length);
		    stmt.execute();
		} catch(err) {
		    this.warn("Error trying to update certificate: "+ err);
		} finally {
		    stmt.reset();
		}
	    }

	    // If the cert info was stored in the previous version of CertPatrol
	    // we don't have the full cert yet, so we just store it in the DB
	    // and return if everything looks fine.
	    if (!certobj.sql.cert &&
		certobj.sql.sha1Fingerprint == certobj.moz.sha1Fingerprint &&
		certobj.sql.md5Fingerprint == certobj.moz.md5Fingerprint)
		    return;

	    if (!wild) {
		// try to make some sense out of the certificate changes
		var natd = this.timedelta(certobj.sql.notAfter);
		// certificate has expired
		if (natd <= 0) certobj.info += this.strings.getString("warn_notAfter_expired") +"\n";
		// certificate still a long way to go
		else if (natd > 7777777777) {
##       	//else if (natd > 10364400000) {
		    certobj.threat ++;
		    certobj.info += this.strings.getString("warn_notAfter_notdue") +"\n";
##		    // used to make it += 2 here, but in cases where server farms
##		    // use several valid certificates for the same host name that's
##		    // just too strict.
##		} else if (natd > 5182200000) {
##		    certobj.threat ++;
##		    certobj.info += this.strings.getString("warn_notAfter_due") +"\n";
		}
		// certificate due sometime soonish
		else if (natd > 0) certobj.info += this.strings.getString("warn_notAfter_due") +"\n";
		// has the certificated hostname changed?
		if (certobj.moz.commonName != certobj.sql.commonName) {
		    certobj.info += this.strings.getString("warn_commonName") +"\n";
		    certobj.threat += 2;
		}
	    }

## VeriSign case suggests i should compare issuerOrganization instead...
	    // again, check if they have the same issuer
	    if (certobj.sql.cert && !certobj.moz.cert.issuer.equals(certobj.sql.cert.issuer) || // new
		!certobj.sql.cert && (certobj.moz.issuerOrganization != certobj.sql.issuerOrganization || // old
				      certobj.moz.issuerCommonName != certobj.sql.issuerCommonName)) {
		certobj.info += this.strings.getString("warn_issuerCommonName") +"\n";
		certobj.threat += 2;
	    }
	    // now looking into the NEW certificate
	    var td = this.timedelta(certobj.moz.notBefore);
	    if (td > 0) {
		// new certificate isn't valid yet
		certobj.info += this.strings.getString("warn_notBefore") +"\n";
		certobj.threat += 2;
	    }
	    // further checks done by agent before we even get here

	    // fetch suitable scare message
	    if (certobj.threat > 3) certobj.threat = 3;
	    certobj.lang.changeEvent += " "+ this.strings.getString("threatLevel_"+ certobj.threat);

	    // produce human readable expiration dates
	    certobj.sql.notBefore = this.isodate(certobj.sql.notBefore) +
	      this.daysdelta(this.timedelta(certobj.sql.notBefore));
	    certobj.sql.notAfter = this.isodate(certobj.sql.notAfter) +
	      this.daysdelta(natd);
	    certobj.moz.notBefore = this.isodate(certobj.moz.notBefore) +
	      this.daysdelta(this.timedelta(certobj.moz.notBefore));
	    certobj.moz.notAfter = this.isodate(certobj.moz.notAfter) +
	      this.daysdelta(this.timedelta(certobj.moz.notAfter));

	    if (wild && certobj.threat == 0) {
		certobj.info += this.strings.getString("warn_wildcard") +"\n";
		this.outwild(browser, certobj);
		return;
	    }
	    this.outchange(browser, certobj);

	    // New certificate
	} else if (!found) {
	    if (!pbm) {
		// Store data
		stmt = this.dbinsert;
		try {
		    stmt.bindUTF8StringParameter( 0, certobj.host);
		    stmt.bindUTF8StringParameter( 1, certobj.moz.commonName);
		    stmt.bindUTF8StringParameter( 2, certobj.moz.organization);
		    stmt.bindUTF8StringParameter( 3, certobj.moz.organizationalUnit);
		    stmt.bindUTF8StringParameter( 4, certobj.moz.serialNumber);
		    stmt.bindUTF8StringParameter( 5, certobj.moz.emailAddress);
		    stmt.bindUTF8StringParameter( 6, certobj.moz.notBefore);
		    stmt.bindUTF8StringParameter( 7, certobj.moz.notAfter);
		    stmt.bindUTF8StringParameter( 8, certobj.moz.issuerCommonName);
		    stmt.bindUTF8StringParameter( 9, certobj.moz.issuerOrganization);
		    stmt.bindUTF8StringParameter(10, certobj.moz.issuerOrganizationUnit);
		    stmt.bindUTF8StringParameter(11, certobj.moz.md5Fingerprint);
		    stmt.bindUTF8StringParameter(12, certobj.moz.sha1Fingerprint);
		    stmt.bindUTF8StringParameter(13, certobj.moz.issuerMd5Fingerprint);
		    stmt.bindUTF8StringParameter(14, certobj.moz.issuerSha1Fingerprint);
		    var der = certobj.moz.cert.getRawDER({});
		    stmt.bindBlobParameter(15, der, der.length);
		    stmt.execute();
		} catch(err) {
		    this.warn("Error trying to insert certificate for "+certobj.host+
		      ": "+err);
		} finally {
		    stmt.reset();
		}
	    }
##	    // checks are done by firefox before we even get here
##	    // that's why we don't complain about host != common name etc.
	    certobj.moz.notBefore = this.isodate(certobj.moz.notBefore) +
	      this.daysdelta(this.timedelta(certobj.moz.notBefore));
	    certobj.moz.notAfter = this.isodate(certobj.moz.notAfter) +
	      this.daysdelta(this.timedelta(certobj.moz.notAfter));

	    this.outnew(browser, certobj);
	}
    },

    // wildcardCertCheck contributed by Georg Koppen, JonDos GmbH 2010. Thanks!
    // We are using it differently, though. The JonDos version is less paranoid.
    //
    wildcardCertCheck: function(commonName, sha1Fingerprint) {
	var stmt;

	// First, we check whether we have a wildcard certificate at all. If not
	// just return false and the new cert dialog will be schown. But even if
	// we have one but no SHA1 fingerprint we should show it for security's
	// sake...
##  alert("doing wildcardCertCheck for "+ sha1Fingerprint);
	if (commonName.charAt(0) === '*' && sha1Fingerprint) {
	    // We got one, check now if we have it already. If not, return false and
	    // the certificate will be shown. Otherwise, return yes and the new cert
	    // dialog will be omitted.
	    try {
		stmt = this.dbselectWild;
		// starts counting from 0, so ?13 is 12 here. you gotta love it.
		stmt.bindUTF8StringParameter(12, sha1Fingerprint);
		if (stmt.executeStep()) {
		    return true;
		} else {
		    // This case could occur as well if we have *.example.com and
		    // foo.example.com with SHA1(1) saved and we find a cert with
		    // *.example.com and bar.example.com and SHA1(2): We would show
		    // the dialog even if we have already saved the wildcard cert. But
		    // that's okay due to the changed SHA1 fingerprint, thus prioritizing
		    // security and not convenience...
		    return false;
		}
	    } catch (err) {
		this.warn("Error trying to check wildcard certificate "+ commonName
		  +": "+ err);
	    } finally {
		stmt.reset();
	    }
	} else {
	    return false;
	}
    },

    outnew: function(browser, certobj) {
	var forcePopup = false;
	if (this.prefs) forcePopup = this.prefs.getBoolPref("popup.new");

##	// would like to use document's browser here, but it doesn't work
	var notifyBox = gBrowser.getNotificationBox(browser);
	if (forcePopup || notifyBox == null) {
	    window.openDialog("chrome://certpatrol/content/new.xul", "_blank",
			      "chrome,dialog,modal", certobj, CertPatrol);
	    return;
	}
##      // https://developer.mozilla.org/en/XUL/Method/appendNotification
##      // http://gist.github.com/256554
##      // using certobj.host as the id for the notification
	notifyBox.appendNotification(
	  "(CertPatrol) "+ certobj.lang.newEvent
	  +" "+ certobj.moz.commonName +". "+
	  certobj.lang.issuedBy +" "+
	  (certobj.moz.issuerOrganization || certobj.moz.issuerCommonName),
	  certobj.host, null,
	  notifyBox.PRIORITY_INFO_HIGH, [ {
	      accessKey: "D",
	      label: certobj.lang.viewDetails,
	      callback: function(msg, btn) {
		  window.openDialog("chrome://certpatrol/content/new.xul",
				    "_blank", "chrome,dialog,modal", certobj, CertPatrol);
	      }
	}, ]);
    },

    outwild: function(browser, certobj) {
	var forcePopup = false;
	if (this.prefs) forcePopup = this.prefs.getBoolPref("popup.wild");

	var notifyBox = gBrowser.getNotificationBox(browser);
	if (forcePopup || notifyBox == null) {
	    window.openDialog("chrome://certpatrol/content/change.xul",
			      "_blank", "chrome,dialog,modal", certobj, CertPatrol);
	    return;
	}
	notifyBox.appendNotification(
	  "(CertPatrol) "+ certobj.lang.wildEvent
	  +" "+ certobj.moz.commonName +". "+
	  certobj.lang.issuedBy +" "+
	  (certobj.moz.issuerOrganization || certobj.moz.issuerCommonName),
	  certobj.host, null,
	  notifyBox.PRIORITY_INFO_HIGH, [ {
	      accessKey: "D",
	      label: certobj.lang.viewDetails,
	      callback: function(msg, btn) {
		  window.openDialog("chrome://certpatrol/content/change.xul",
				    "_blank", "chrome,dialog,modal", certobj, CertPatrol);
	      }
	}, ]);
    },

    outchange: function(browser, certobj) {
	var forcePopup = false;
	if (this.prefs) forcePopup = this.prefs.getBoolPref("popup.change");

	var notifyBox = gBrowser.getNotificationBox(browser);
	if (forcePopup || certobj.threat > 1 || notifyBox == null) {
	    window.openDialog("chrome://certpatrol/content/change.xul", "_blank",
			      "chrome,dialog,modal", certobj, CertPatrol);
	    return;
	}
	notifyBox.appendNotification(
	  "(CertPatrol) "+ certobj.lang.changeEvent
	  +" "+ certobj.moz.commonName +". "+
	  certobj.lang.issuedBy +" "+
	  (certobj.moz.issuerOrganization || certobj.moz.issuerCommonName)
	  +" "+ certobj.info,
	  certobj.host, null,
	  certobj.threat > 0 ? notifyBox.PRIORITY_WARNING_HIGH
	  : notifyBox.PRIORITY_INFO_LOW, [ {
	      accessKey: "D",
	      label: certobj.lang.viewDetails,
	      callback: function(msg, btn) {
		  window.openDialog("chrome://certpatrol/content/change.xul",
				    "_blank", "chrome,dialog,modal", certobj, CertPatrol);
	      }
	}, ]);
    },

    warn: function(result) {
	window.openDialog("chrome://certpatrol/content/warning.xul",
	  /* "ssl-warning" */ "_blank", "chrome,dialog,modal", result);
    },

    log: function(s, a) {
	if (a && a.length && a.join)
	    s += ' ' + a.join(', ');
	Components.classes["@mozilla.org/consoleservice;1"].getService(Components.interfaces.nsIConsoleService).logStringMessage(s);
    },

    // functions for the new & change dialogs

    addCertChain: function(node, cert) {
	var chain = cert.getChain();
	var text = '';
	for (var i = chain.length - 1; i >= 0; i--) {
            var cert = chain.queryElementAt(i, Components.interfaces.nsIX509Cert);
	    text += Array((chain.length - i - 1) * 2 + 1).join(' ') + '- ' + (cert.commonName || cert.windowTitle) + (i > 0 ? '\n' : '');
	}
	node.value = text;
	node.clickSelectsAll = true;
	node.setAttribute("rows", chain.length);
    },

    viewCert: function(cert) {
	Components.classes["@mozilla.org/nsCertificateDialogs;1"]
            .getService(Components.interfaces.nsICertificateDialogs)
	    .viewCert(null, cert);
    },
};

window.addEventListener("load", function(e) { CertPatrol.onLoad(e); }, false);
